#!/usr/bin/env bash
# shellcheck disable=SC2015,SC1090,SC2191,SC2218

# MIT license (c) 2021 https://github.com/slowpeek
# Homepage: https://github.com/slowpeek/vanilla

_ () {
    unset -f _

    local v=("${BASH_VERSINFO[@]}")
    if ((v[0] < 4 || (v[0] == 4 && v[1] < 3))); then
        echo "This script requires bash 4.3. Yours is ${v[0]}.${v[1]}"
        exit 1
    fi
}; _

set -eu

! test -f "${BASH_SOURCE[0]%/*}"/locate-exit.sh || source "$_"

# --------------------------------------------------------------
# MIT license (c) 2021 https://github.com/slowpeek
# Homepage: https://github.com/slowpeek/here-bye

_ () {
    unset -f _

    IFS=, read -r -a HERE_PREFIX <<< "${HERE_PREFIX-}"
    IFS=, read -r -a BYE_PREFIX <<< "${BYE_PREFIX-}"
}; _

here () {
    if (($# > 0)); then
        if [[ -v HERE_PREFIX ]]; then
            printf '[%s]' "${HERE_PREFIX[@]}"
            echo -n ' '
        fi

        local IFS=' '
        printf '%s\n' "$*"
    fi
}

here2 () {
    here "$@" >&2
}

bye () {
    if [[ -v BYE_PREFIX ]]; then
        HERE_PREFIX=(
            "${BYE_PREFIX[@]}"
            ${HERE_PREFIX[@]+"${HERE_PREFIX[@]}"}
        )
    fi

    here "$@" >&2
    exit "${BYE_EXIT:-1}"
}
# --------------------------------------------------------------

# Rename bye => org_bye
eval org_"$(declare -f bye)"

here_prefix () {
    HERE_PREFIX+=("$1")
}

here_unprefix () {
    unset -v 'HERE_PREFIX[-1]'
}

here_color () {
    if [[ -v HERE_PREFIX ]]; then
        HERE_PREFIX[-1]=$1${HERE_PREFIX[-1]}$'\e[0m'
        undo=trim
    else
        here_prefix "$1$2"$'\e[0m'
        undo=pop
    fi
}

here_uncolor () {
    if [[ $1 == trim ]]; then
        HERE_PREFIX[-1]=${HERE_PREFIX[-1]:5:-4}
    else
        here_unprefix
    fi
}

here_colorful () {
    local undo
    here_color "$1" "$2"
    here "${@:3}"
    here_uncolor "$undo"
}

here_success () {
    here_colorful $'\e[32m' success "$@"
}

here_warn () {
    here_colorful $'\e[33m' warning "$@"
}

here_error () {
    here_colorful $'\e[31m' error "$@"
}

bye () {
    local undo
    here_color $'\e[31m' error
    org_bye "$@"
}

curl () {
    command curl --connect-timeout 3 --compressed -f "$@"
}

is_bin () {
    type -P "$1" >/dev/null
}

need_bin () {
    local bin

    for bin; do
        ! is_bin "$bin" || return 0
    done

    local msg='cant find '
    (($#>1)) && msg+="any of binaries: $*" || msg+="binary: $1"

    bye "$msg"
}

version_le () {
    printf '%s\n' "$1" "$2" | sort --check=quiet -V
}

_dir () { [[ -d $1 ]] || bye "'$1' is not a dir"; }
w_dir () { [[ -w $1 && -x $1 ]] || bye "'$1' is not writable"; }
r_dir () { [[ -r $1 && -x $1 ]] || bye "'$1' is not readable"; }

set_pkg () {
    local name names
    for name in firefox{,-esr,-beta} thunderbird{,-beta}; do
        if [[ $1 == "$name" ]]; then
            pkg=${1%-*}
            [[ $pkg == "$1" ]] && type=release || type=${1#*-}
            return
        fi

        names+=("$name")
    done

    bye "valid package names are: ${names[*]}"
}

installed_versions () {
    r_dir "$base"

    [[ $1 == list ]] || local -n list=$1
    list=()

    local dir
    for dir in $(cd "$base"; compgen -G "$pkg-[0-9]*/" | sort -Vr); do
        dir=${dir::-1}

        if [[ $dir == *esr ]]; then
            [[ $type == esr ]] || continue
            list+=("$dir")
        elif [[ $dir == *[0-9]b+([0-9]) ]]; then
            [[ $type == beta ]] || continue
            list+=("$dir")
        else
            [[ $type == release ]] || continue
            list+=("$dir")
        fi
    done

    # Mark the selected version.
    local sel
    if test -h "$base/$name"; then
        sel=$(readlink "$_")

        if [[ $sel == "$pkg"-[0-9]* ]]; then
            sel=${sel#*-}
            list=("${list[@]/%$sel/$sel*}")
        fi
    fi

    [[ ! -v list ]] || list=("${list[@]#*-}")
}

list_installed () {
    here_prefix list-installed

    local name pkg type list sel empty=y
    for name; do
        set_pkg "$name"

        installed_versions list
        [[ -v list ]] || continue

        empty=n

        echo "$name"
        printf '    %s\n' "${list[@]}"
        echo
    done

    [[ $empty == n ]] || here_warn 'nothing to list' >&2
    here_unprefix
}

latest_version () {
    need_bin curl

    [[ $1 == ver ]] || local -n ver=$1
    ver=

    local -A patterns=(
        [release]='\d+\.\d+(\.\d+)?'
        [beta]='\d+\.0b\d+'
        [esr]='\d+\.\d+(\.\d+)?esr'
    )

    ver=$(curl -sS "$base_url/" 2>/dev/null |
              grep -oP "${patterns[$type]}(?=/</a>)" |
              sort -Vr | head -n1)

    [[ -n $ver ]] || bye "cant get latest $name version"
}

check_gpg_key () {
    here_prefix gpg
    need_bin gpg

    local key=14F26682D0916CDD81E37B6D61B7B526D98F0353

    if ! gpg --list-key "$key" &>/dev/null; then
        # keyserver.ubuntu.com still works with trusty
        gpg --recv-keys --keyserver keyserver.ubuntu.com "$key" || bye 'key fetch fail'
        here_success 'key fetch OK'
    fi

    here_unprefix
}

download_latest () {
    here_prefix download
    here "pkg=$name lang=$lang"

    local installed best=none
    installed_versions installed
    [[ ! -v installed ]] || best=${installed[0]%\*}

    here "installed version: $best"

    local latest
    latest_version latest
    here "latest version: $latest"

    if [[ -v installed ]] && version_le "$latest" "$best"; then
        here 'no updates available'
        exit
    fi

    __on_error () {
        rm -f "$fn"             # Remove partially downloaded file.

        if [[ $1 == sigint ]]; then
            echo >&2
            bye 'interrupted'
        fi

        bye 'curl error'
    }

    local fn n=0
    for fn in "$pkg-$latest.tar.bz2"{.asc,}; do
        [[ ! -e $fn ]] || continue

        ((n++)) || [[ -w . ]] || bye "'$PWD' is not writable"

        trap '__on_error sigint' SIGINT
        curl -O "$base_url/$latest/linux-$HOSTTYPE/$lang/$fn" || __on_error error
        trap SIGINT
    done

    unset -f __on_error

    ((n)) && here_success "$n files fetched" || here 'skip fetch'

    check_gpg_key

    gpg --verify "$fn".asc || bye 'gpg verify fail'
    here_success 'good gpg signature'

    if (($#)); then
        [[ $1 == file ]] || local -n file=$1
        # shellcheck disable=SC2034
        file=$fn
    fi

    here_unprefix
}

pick_version () {
    [[ $1 == result ]] || local -n result=$1
    result=

    local list
    installed_versions list

    if [[ ${2-} == best ]]; then
        [[ -v list ]] || return 0

        result=${list[0]}
        return
    fi

    if [[ ! -v list ]]; then
        here_warn 'the package is not installed' >&2
        return 1
    fi

    local reply
    if [[ $fzf == n ]]; then
        echo -e "\n$2:\n"

        local PS3=$'\nYour choice: '
        select _ in "${list[@]}"; do
            break
        done <<< a

        read -r reply || true
        echo
    else
        local header="
Quit: Esc / Ctl-D
--------------------------

$2:

"

        local fzf_args=(
            --phony
            --with-nth=2..
            --header="${header:1}"
            --prompt=''
            --height="$((${#list[@]} + 9))"
            --reverse
            --no-info
            --bind=change:clear-query
            --border
        )

        read -r reply _ < \
             <(printf '%s\n' "${list[@]}" | cat -n | fzf "${fzf_args[@]}") || true
    fi

    if [[ -n $reply ]]; then
        [[ $reply == [1-9]*([0-9]) ]] && ((reply <= ${#list[@]})) || {
            here_error 'there was no such option'
            return 1
        }

        # shellcheck disable=SC2034
        result=${list[reply-1]}
    fi
}

select_version () {
    here_prefix select

    local choice q=best
    [[ ${1-} == best ]] || q="Which version of $name the symlink should point to"

    pick_version choice "$q" || exit

    if [[ -z $choice || $choice == *\* ]]; then
        [[ ${1-} == best ]] || here 'no changes'
        exit
    fi

    local link=$base/$name link_action=set

    if [[ -h $link ]]; then
        [[ ! $(readlink "$link") == "$pkg"-[0-9]* ]] || link_action=update
    else
      [[ ! -e $link ]] || bye "'$link' is not a symlink"
    fi

    w_dir "$base"
    ln -sfT "$pkg-$choice" "$link" || bye "cant $link_action '$link'"

    here_success "$link_action link: $name => $pkg-$choice"
    here_unprefix
}

delete_version () {
    here_prefix delete

    local choice
    pick_version choice "Which version of $name to delete" || exit

    if [[ -z $choice ]]; then
        here 'no changes'
        exit
    fi

    w_dir "$base"

    local sel_best=n
    if [[ $choice == *\* ]]; then
        choice=${choice::-1}

        sel_best=y
        # Always remove the symlink along with the selected version so
        # that if it was the only version installed there is no
        # dangling symlink left.
        rm "$base/$name" || bye "cant delete '$_'"
    fi

    rm -r "$base/$pkg-$choice" || bye "cant delete '$_'"

    here_success "$pkg-$choice has been removed"
    here_unprefix

    [[ $sel_best == n ]] || select_version best
}

prune_versions () {
    here_prefix prune

    local installed
    installed_versions installed

    [[ -v installed ]] || bye 'the package is not installed'

    local n=${num-2}
    ((n > 0)) || bye '-n value cant be zero'

    (((n = ${#installed[@]} - n) > 0)) || {
        here 'no changes'
        exit
    }

    local list=() item
    for item in "${installed[@]:(-n)}"; do
        if [[ $item == *\* ]]; then
            item=${installed[-n-1]}
        fi

        list+=("$item")
    done

    for item in "${list[@]}"; do
        rm -r "$base/$pkg-$item" || bye "cant delete '$_'"
        here_success "$pkg-$item has been removed"
    done

    here_unprefix
}

list_langs () {
    here_prefix langs
    here "pkg=$name"

    local latest
    latest_version latest
    here "latest version: $latest"

    local langs
    # 'cat' is used below to ensure pipe status=0
    readarray -t langs < <(curl -sS "$base_url/$latest/linux-$HOSTTYPE/" 2>/dev/null |
                               grep -oP '(?<=>)[^/]+(?=/</a>)' | cat)

    [[ -v langs ]] || bye "cant list langs for $name"

    need_bin column

    echo -e "\n${#langs[@]} available languages:\n"
    printf '%s\n' "${langs[@]}" | pr -t8 -s' ' | column -t

    here_unprefix
}

desktop_file () {
    local app_name=${pkg^}

    case $type in
        beta)
            app_name+=' Beta'
            ;;
        esr)
            app_name+=' ESR'
            ;;
    esac

    local exec=${name}
    [[ $search == y ]] || exec=$base/$name/$pkg

    local icon=${base}/${name}/chrome/icons/default/default128.png

    if [[ $pkg == firefox* ]]; then
        cat <<EOF
[Desktop Entry]
Version=1.0
Name=${app_name}
Exec=${exec} %u
Categories=Network;WebBrowser;
Type=Application
MimeType=text/html;text/xml;application/xhtml+xml;application/xml;application/rss+xml;application/rdf+xml;image/gif;image/jpeg;image/png;x-scheme-handler/http;x-scheme-handler/https;x-scheme-handler/chrome;video/webm;application/x-xpinstall;
Icon=${icon}
Terminal=false
StartupNotify=true
Actions=new-window;new-private-window;

[Desktop Action new-window]
Name=Open a new window
Exec=${exec} -new-window

[Desktop Action new-private-window]
Name=Open a new private window
Exec=${exec} -private-window

EOF
    else
        cat <<EOF
[Desktop Entry]
Version=1.0
Name=${app_name}
Exec=${exec} %u
Categories=Network;Email;
Type=Application
MimeType=x-scheme-handler/mailto;application/x-xpinstall;
Icon=${icon}
Terminal=false
StartupNotify=true
Actions=compose;contacts

[Desktop Action compose]
Name=Compose new message
Exec=${exec} -compose

[Desktop Action contacts]
Name=Contacts
Exec=${exec} -addressbook

EOF
    fi
}

install_file () {
    here_prefix install-file

    [[ -f $1 ]] || bye "'$1' is not a regular file"
    [[ -r $1 ]] || bye "'$1' is not readable"
    [[ $1 == *.tar.bz2 ]] || bye "'$1' is not a .tar.bz2 archive"

    local fn=${1##*\/}

    [[ $fn == @(firefox|thunderbird)-[1-9]* ]] ||
        bye "'$1' doesnt look like a mozilla package"

    w_dir "$base"

    local dir=$base/${1%.tar.bz2}
    if [[ -e $dir ]]; then
        _dir "$dir"
        w_dir "$dir"
    else
        mkdir "$dir"
    fi

    here "extract to '$dir'"

    need_bin bzip2 lbzip2

    local args=(-C "$dir" --strip-components=1 --checkpoint=.400)
    ! is_bin lbzip2 || args+=(-I lbzip2)
    tar xf "$1" "${args[@]}" || bye 'extract fail'

    echo
    here_success 'extract OK'
    here_unprefix
}

# https://github.com/slowpeek/jetopt
jetopt () {
    local s type mode='' short='' long=''

    while (($#)); do
        # Break on any literal option or '--'
        [[ ! $1 == -* ]] || break

        s=$1
        shift

        # Scanning mode.
        if [[ $s == ,* ]]; then
            [[ ! $s == ,[+-] ]] || mode=${s:1}
            continue
        fi

        # Option type.
        type=''
        if [[ $s == *: ]]; then
            [[ $s == *:: ]] && type=:: || type=:
            s=${s%$type}
        fi

        # Short option, if present.
        [[ $s == .* ]] || short+=${s::1}$type

        # Long option, if present.
        test -z "${s:1}" || long+=,$_$type
    done

    getopt -o "$mode$short" -l "${long:1}" "$@"
}

install_latest () {
    local token=${BASH_SOURCE[0]##*/}
    token=${token%%.*}

    # Readonly flag is used here to protect $dir from unintentional
    # changes until the dir is deleted.
    local -r dir=${TMPDIR:-/tmp}/$token:$name

    [[ -e $dir ]] && _dir "$dir" || mkdir "$dir"
    pushd "$dir" >/dev/null

    local file
    download_latest file

    install_file "$file"

    (select_version best) || exit

    popd >/dev/null
    rm -r "$dir"
}

check_reqs () {
    # arch
    [[ $HOSTTYPE == @(x86_64|i686) ]] ||
        bye 'Mozilla only provides packages for x86_64 and i686.' \
            "Your arch is $HOSTTYPE"

    # glibc
    local req=2.17 line

    read -r line < <(ldd --version)
    line=${line##*[[:space:]]}

    if [[ $line == 2.* ]]; then
        version_le "$req" "$line" ||
            here_warn "glibc $line is not supported." \
                      "Mozilla builds require glibc $req at least."
    else
        here_warn 'cant figure out glibc version'
    fi
}

check_empty () {
    while (($#)); do
        [[ -n ${!1} ]] || bye "${2:---$1} value cant be empty"
        shift 2
    done
}

check_num () {
    [[ -v num ]] || return 0    # OK if not set

    check_empty num -n

    [[ $num == +([[:digit:]]) ]] || bye '-n value must be a non-negative number'

    num=${num#${num%%[^0]*}}    # ltrim '0' to prevent octal syntax
    [[ -n $num ]] || num=0
}

check_fzf () {
    local custom=${fzf+y}
    fzf=${fzf-y}

    [[ $fzf == y ]] && is_bin fzf || {
            fzf=n
            return
        }

    local req=0.20 ver

    # '0.20.0' in focal
    # '0.24 (dev)' in implish
    # '0.27.2 (8255aa2)' in arch
    read -r ver _ < <(fzf --version)

    [[ -z $custom ]] && ! version_le "$req" "$ver" || return 0

    fzf=n

    here_warn "You fzf is older than $req, the fzf picker is disabled by default."
    here_warn 'You can force enable it with --fzf or hide this warning with --no-fzf'
}

import_conf () {
    local conf
    for conf in {/etc,~/.config}/vanillarc; do
        ! [[ -f $conf && -r $conf ]] ||
            source "$conf" || bye "error while sourcing '$conf'"
    done
}

usage () {
    local self=${BASH_SOURCE[0]##*/}

    cat <<EOF
USAGE

Install or upgrade
    ${self} install [--lang <lang>] [--base <dir>] <package>

Step by step install
    ${self} download [--lang <lang>] [--base <dir>] <package>
    ${self} install-file [--base <dir>] <file>
    ${self} select [--base <dir>] [--fzf|--no-fzf] <package>

Uninstall
    ${self} delete [--base <dir>] [--fzf|--no-fzf] <package>
    ${self} prune [--base <dir>] [-n <num>] <package>

Utils
    ${self} list-installed [package]
    ${self} list-langs <package>
    ${self} desktop-file [--base <dir>] [--no-path] <package>

Package is one of: firefox, firefox-beta, firefox-esr, thunderbird,
thunderbird-beta.


OPTIONS SUMMARY

-b --base <dir>
    Base dir for installations. By default '/opt/mozilla'.

-l --lang <lang>
    Package language to download. By default 'en-US'.

-n <num>
    Generic 'number' option.

--no-path
    Only applicable to the 'desktop-file' command. By default the
    'Exec' property contains a full path to the binary. With this
    option it would be just a package name like 'firefox' or
    'firefox-esr'.

--fzf --no-fzf
    Override the default behavior of the interactive picker.


ENV VARS

Some settings can be set with env vars instead of options. As usually,
options override the corresponding vars if both are set.

    VANILLA_BASE
        Same as -b/--base

    VANILLA_LANG
        Same as -l/--lang

    VANILLA_FZF
        'y' for --fzf, 'n' for --no-fzf. Other values are ignored.


CONFIG FILES

Alternative to env vars, you can set the vars in '/etc/vanillarc' or
'~/.config/vanillarc'. Settings in the latter override the former.


COMMANDS

install
    Install or try to upgrade a package and refresh its symlink in the
    base dir.

download
    Download the latest version of a package into the current dir if
    only an update is available and verify the signature.

install-file
    Install a previously downloaded archive into the base dir.

select
    Interactively select the version for a package's symlink in the base
    dir.

delete
    Interactively select and delete a version of a package from the
    base dir and adjust the package's symlink if needed.

prune
    Delete old versions of a package from the base dir. By default
    only 2 most recent versions are kept including the selected
    one. '-n' option can be used to change the default.

list-installed
    List installed versions for a package or all packages.

list-langs
    List available languages for the latest version of a package.

desktop-file
    Generate a desktop file for the package.


More details at https://github.com/slowpeek/vanilla

EOF
    exit
}

main () {
    check_reqs

    (($#)) || usage

    local opts
    opts=$(jetopt llang: bbase: n: \
                  .no-path .fzf .no-fzf -- "$@") || bye 'options error'
    eval set -- "$opts"
    unset -v opts

    import_conf

    local lang=${VANILLA_LANG-en-US} base=${VANILLA_BASE-/opt/mozilla}
    local search=n fzf num

    [[ ! ${VANILLA_FZF-} == [yn] ]] || fzf=$VANILLA_FZF

    while true; do
        case $1 in
            --)
                shift
                break
                ;;
            --no-path)
                search=y
                ;;
            --fzf)
                fzf=y
                ;;
            --no-fzf)
                fzf=n
                ;;
            -l|--lang)
                lang=$2
                shift
                ;;
            -b|--base)
                base=$2
                shift
                ;;
            -n)
                num=$2
                shift
                ;;
        esac

        shift
    done

    check_empty lang '' base ''
    check_num
    check_fzf

    (($#)) || bye 'command name is required'

    local mode=$1
    shift

    local -A ctrl=(
        [install]=install_latest
        [download]=download_latest
        [install-file]=self
        [select]=select_version
        [delete]=delete_version
        [prune]=prune_versions
        [list-installed]=self
        [list-langs]=list_langs
        [desktop-file]=desktop_file
    )

    [[ -v ctrl[$mode] ]] || bye "unknown command '$mode'"

    if [[ $mode != list-langs ]]; then
        _dir "$base"

        # Ensure $base is an absolute path.
        if [[ $base != /* ]]; then
            is_bin realpath && base=$(realpath -s "$base") ||
                    base=$(readlink -m "$base")
        fi
    fi

    case $mode in
        install-file)
            (($#)) || bye 'file name is required'

            install_file "$1"
            return
            ;;

        list-installed)
            local args
            (($#)) && args=("$1") || args=(firefox{,-esr,-beta} thunderbird{,-beta})
            list_installed "${args[@]}"
            return
            ;;
    esac

    (($#)) || bye 'package name is required'

    local name=$1 pkg type
    set_pkg "$name"

    local base_url=https://download-installer.cdn.mozilla.net/pub/$pkg/releases

    "${ctrl[$mode]}"
}

[[ ! ${BASH_SOURCE[0]} == "$0" ]] || main "$@"
